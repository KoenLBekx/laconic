LACONIC

		// TODO: explain standard number of operands and how to deviate from it.
		// TODO: indicate the standard number of operands for every operator.

		* Characters assigned to operators:
			~+-*/%^$():`;=<>!&|?°AabCceFilMmOoprSsTUuvWwxZ

		*	Implemented operators:
			~+-*/%^$():`;=<>!&|?° a CceFilMmOoprS T  vWwxZ

		* Characters not to be used as operator:
			' "     interfere with command line syntax
			. [ ] # have other meanings in Laconic.
			whitespace

		* Common characters not used yet:
			´@\{},§£€¶BDdEfGgHhIJjKkLNnPQRqtVXz

			Note the Unicode point of some characters not on all keyboards:
				^ 005E Circumflex accent
				` 0060 Grave accent or Backtick
				~	007E Tilde
				£ 00A3 Pound
				§ 00A7 Section (paragraph) sign
				° 00B0 Degrees sign
				´ 00B4 Acute accent
				¶ 00B6 Pilcrow
				€ 20AC Euro

	General syntax

		The Laconic language is a Polish expression interpreter :

			*+4 2 3

		evaluates to 18.

		A Laconic expression consists of atoms that can either be
		- operators
		- numbers
		- string bracket contents
		- comment bracket contents
		- number bracket contents

		All atoms are case-sensitive.

		If there are more atoms than expected by the preceding operators,
		the preceding results are discarded and the value of the remaining expression is returned.

		E.g.:

			*+4 2 3 25

		will return 25, just like

			*+4 2 3 + 19 6

	Operators

		All operators consist of a single character that precedes its operands.

		See below for a detail explanation of each operator.

		There's never a need to separate an operator from preceding or following atoms using a whitespace,
		but it's permitted for readability.

		Note: the characters " and ' are nowhere used in Laconic, as they interfere with command line syntax.

		Note: there are also enumerated operators - see the O and o operators.

		Every operator has a default number of operands it expects. E.g., the + operator expects two operands :
		+ 1 2 yields 3.

		However, many operators can operate on less or more operands, too, but in order to deviate from the default number, the ( and ) operators have to be used:

		+(1 2 3) yields 6.
		+(27) yields 27.

	Numbers

		Numbers consist of characters 0 up to 9, and may contain exactly one period as fractal separator. (Unary minus, ~, is an operator.)
		If the number is between 1 and -1 exclusive, the period may be the first character of the number.
		For readability, underscores _ may be inserted anywhere in a number :
		(In fact, prior to the interpretion of a formula, all underscores are discarded from it.)

		Eg.:
			.000_001 = 0.000001
			1_000_000 = 1000000

		A number is allowed to end with a period :

			40. = 40

		And a sole period is interpreted as zero :

			. = 0

		Note that a second period in a number is considered to be the start of the repeating part of a number:
				 (To be implemented.)

			12.3.8 is interpreted as 12.3888...

			so

			12.3.9 yields 12.4

			(See 
				Su, Francis E., et al. “Why Does 0.999… = 1?.” Math Fun Facts
				https://math.hmc.edu/funfacts/why-does-0-999-1/
			)

		A third period in a number is interpreted as the start of a new number between 1 and ~1 exclusively:
				 (To be implemented.)

			+1.0.0.2

			is interpreted as

			+1 .2
			
			and yields

			1.2

			Using the b n command one can use other bases than 10 for the script's numbers.

			However, as non-decimal-digit characters are interpreted as commands,
			numbers using a base larger than 10 and having digits above 9
			should be enclosed in a [n...] clause. E.g.:

			b 16 [n1F] yields 31(base10)

			but

			b 16 10 yields 16(base10)

		Number bases
				 (To be implemented.)

			The default number base is 10.

			However, using the b and b` operators, one can switch to other bases for input and output.

			Digits for bases greater than 10 consist of 0 to 9 and the appropriate number of upper case letters needed:

			base  2 :  0-1
			base  3 :  0-2
			base  8 :  0-7
			base 10 :  0-9
			base 11 :  0-9 and A
			base 12 :  0-9 and A-B
			base 16 :  0-9 and A-F
			base 17 :  0-9 and A-G
			base 36 :  0-9 and A-Z
			base 37 :  0 - 9 and 10 - 36
			base 200 : 0 - 9 and 10 - 199

			Numbers in bases higher than 10 having digits above 9 should be enclosed in number bracket contents : [n...].

			e.g.:
				b16 [n1A] yields 26.
				b16 1A		will consider the A character to be an operator.
				b16 11    yields 17.

			If a number expressed in a base higher than 36 has digits greater than 35,
			it has to be expressed as number bracket contents: [n...] clauses as series of base10 numbers separated by spaces:

			b50 +[n1 20] 3 yields 73(base10)

			This reduces calculating with hours, minutes and seconds to calculating seconds in base 60:

			b`60 b60 /[n5 20 8] 4 yields 80(base10) : a fourth of 5 hours, 20 minutes and 8 seconds is 4802 seconds or 1 hour, 20 minutes and 2 seconds.
			
			Combinations of b`n and bn commands allow conversion of numbers between bases.
			In order to avoid mistakes in the specification of the output base,
			it's best to issue the b`n expression before the bn expression.

			It's even possible to process numbers of different bases together:

			*17 ;b16 21 yields 561(base10).

			If a number has a digit which is too high for its base, that digit is reduced to the highest one:

				e.g.:
					b 2 104
						yields the same as
					b 2 101
						to wit 5(base10).

	String brackets content

		Strings are enclosed between [s and ]

			Note : an alternative form, that cannot contain whitespace, is the s operator :
			       whatever characters follow constitute a string,
			       until the first whitespace character or square bracket [ found.

		Eg.:

			[sKunji Namparshespa] yields the string "Kunji Namparshespa".

		If any of their operands is a string, some numerical operators will perform string-related operations :

			+	Concatenation, converting any numeric operand to a string;

				Thus
					$20 353 + [sTotal: ] v20
				yields
					"Total: 353"

			- number string : removal of [number] first characters from the string;
			- string number : truncation of the string to first [number] characters.
				(to be implemented)

				Thus
					-- 3 [sLa Roche-en-Ardenne] 5
				yields
					"Roche"

			* string number : repeats the string int(number) times.
				(to be implemented)

				Thus
					* [sblah ] 3
				yields
					"blah blah blah "

			% string number : unicode value of nth character in string
				(to be implemented)

				Thus
					%[sJujube] 4
				yields
					62

			i string : length of string
				(to be implemented)

				Thus
					i[sTheodorakis]
				yields
					11

		Other numerical operators, or other combinations of number and string operands, will ignore the string operands.

	Comment brackets content

		Comments are enclosed between [c and ].

		They are completely ignored by Laconic.

		Eg.:

			$20 100[c Let's populate variable 20 with 100.]v20[c This entire expression should yield 100.]

	Whitespace

		Whitespace (any number of blanks, tabs, CR, LF) is treated as atom separator.

		As operators consist of only one character, they don't need to be separated by whitespace from anything else; two consecutive numbers, however, do.

Operators

	Basic arithmetic

		~ Unary minus

			+1~4 yields ~3
			-1~4 yields 5

		+ Addition of next two operands

			+5 6 yields 11

		- Subtraction

			-6 5 yields 1

		* Multiplication

			* 38 ~5 yields ~190

		/ Division

			/ 504 7 yields 72

		% Modulo (Remainder)

			%7 3 yields 1
			%7.1 3.1 yields .9

		^ Power (exponent)

			^ 2 .5 yields 1.4142...

		l logarithm

				l base num

					l10 1000 yields 3 (actually, it yields 2.999....)
					le  num	 yields the natural logarithm of numbers.

		i Integer

			Truncates the fractal part of a number towards zero:

			i4.7 yields 4
			i~3.8 yields ~3
			i15 yields 15
			i~27 yields ~27

		a Absolute value

			a8 yields 8
			a~3 yields 3

		m Minimum

			m7 4.1 yields 4.1
			m~7 4.1 yields ~7
			m(4 2 1 19) yields 1

		M Maximum

			M7 4.1 yields 7
			M~7 4.1 yields 4.1
			M(4 2 1 19) yields 19

	Trigonometric operators

		S sine of n radians
			
			S°`45 yields 0.7071...

		S` arcsine in radians

			°S`0.7071 yields 44.999 etc.

		C	cosine of n radians

			C°`45 yields 0.7071...

		C` arccosine in radians

			°C`0.7071 yields 44.999 etc.

		T	tangent of n radians

			T°`45 yields 1

		T` arctangent in radians

			°T`1 yields 44.999 etc.

		° degrees from radians

			°p yields 180

		°` radians from degrees

			°`180 yields 3.14159...

		A num num
			(to be implemented)

			atan2()

			(Also to be implemented :)

		S`` hyperbolic sine (sinh)
		S``` inverse hyperbolic sine (asinh)
		C`` hyperbolic cosine (cosinh)
		C``` inverse hyperbolic cosine (acosinh)
		T`` hyperbolic tangent (tanh)
		T``` inverse hyperbolic tangent (atanh)

	Constants (zero-operand operators)

		e Euler's number

		p Pi

		c	num
			enumerated constants

			c0 Golden Ratio (sectio aurea)

				Calculated as (1 + sqrt(5))/2

	Variables

		$ Variable assignment

			Variables are designated by any number, including negative and non-integer ones.
			However, this assignment operator truncates the fractal part of non integer numbers:

			$4.2 10 assigns 10 to variable number 4.
			$4.9 10 assigns 10 to variable number 4 also.
			$~4.9 10 assigns 10 to variable number -4.

			$0+2 8 assigns 10 to variable number 0.

			$+3 1+2 8 assigns 10 to variable number (3 + 1), so variable number 4.

			If the $ operator has more than two operands (used with parentheses),
			then operands 3 up to the last one are assigned to consecutive variables:

			$(10 20 4 5)
				assigns
					20 to variable 10,
					4  to variable 11 and
					5  to variable 12.

		v references a variable

			$2 30 +v2 4 yields 34

		: references and assigns to a variable

			changes the operation of the parent operator into an assignment operation that
			- uses the value of the : operand as a variable number,
			- uses this variable's value as operand for the parent operator,
			- assigns the resulting value of the parent operator to the referenced variable
			- and returns the assigned value :

			+:0 5
				means $0 +v0 5 (Assign to variable(0) the value of variable(0) plus 5)
			+0 :5
				means $5 +0 v5 (Assign to variable(5) the value of 0 plus variable(5))

			~:2
				means $2 ~v2   (Convert the value of variable 2 to its opposite)

			It is even possible to assign the value of the parent operator to two variables referenced as operands:

			$(1 10 20) +:1 :2 +v1 v2
				will yield 60, as the sum of 10 + 20 will be assigned to both variable 1 and 2.

			If using the () operators to override an operator's number of operands,
			and referencing the first operand using the : operator,
			one can choose to put this : operator before or after the ( operator:

			Both expressions do the same :
			+(:0 v1 v2)
			+:(0 v1 v2)

			The : operator takes always only one operand, and if followed by an () operand number overriding clause,  
			this clause is applied to the preceding operator,
			which may or may not be the parent operator.

			This might have surprising effects :

			$(1 10 20) +v2 :(1) v1

				will be interpreted as

			$(1 10 20) +v(2 :1) v1

				where the v operator will yield variable 2's value (20), but assigns it also to variable 1 !
				The + operator will then use v2 and v1 as its operands and yield 40.

		u use variables array having given number for the next statement
			(to be implemented)

			Variables are stored in one of several arrays.
			Each array has a number.
			Using the 'u' command, you can change the array of variables to be used
			for the next single statement.

			Default is array 0.

			The u operator returns the value of the next statement, just like the ; operator.
			This allows for expressions like u2v1 : register 1 from array 2.

			$5 20 v5 yields 20, because the current variables array hasn't been changed.
			$5 20 u1 v5 yields 0, because that's the default value for an unknown variable in an array.

		U use variables array having given number for the subsequent statements
			(to be implemented)

			Variables are stored in one of several arrays.
			Each array has a number.
			Using the 'U' command, you can change the array of variables to be used
			for all subsequent variable-related operations.

			Default is array 0.

			The U operator returns the value of the next statement, just like the ; operator.
			This allows for expressions like U2+v1 v2 : the sum of variables 1 and 2 from array 2.

			$5 20 v5 yields 20, because the current variables array hasn't been changed.
			$5 20 U1 v5 yields 0, because that's the default value for an unknown variable in an array.

	Comparison

		= equality

			Yields 1 if both operands are equal, else 0.

			$0 5 =v0 5 yields 1

			Using the ( and ) operators and more operands,
			one can test if a series of expressions is equal:

			$1 -15 3 =(12 +7 5 *3 4 /36 3 v1) yields 1

			The equality operator takes the precision orb into account.

				(The orb can be set using expression Z 0 n)

			Z0 .1 =21.3 21.35 yields 1

		< less than:

			< 5 20 yields 1

			!< 5 5 yields 1 (greater or equal)
			!< 6 5 yields 1

			Using the ( and ) operators and more operands,
			one can test if a series of numbes is ascending:

			<(2 8 50 401 800) yields 1

		> 

			> 50 20 yields 1

			!> 5 5 yields 1 (less or equal)
			!> 6 50 yields 1

			Using the ( and ) operators and more operands,
			one can test if a series of numbes is descending:

			>(701 90 87 4) yields 1

	Logic

		Note:

			0 = false, everything else = true.

		! not

			Converts 0 to 1, and everything else to 0.

			!4 yields 0
			!1 yields 0
			!0 yields 1

			Used with more than the standard one operand,
			! can be used to test if a series of expressions are all 0.

			!(0 -4 4 * 25 0) yields 1
			!(0 0 9) yields 0

		& logical and : if all operands are non-zero (true), then 1, else zero (false)

			& 7 -5 yields 1
			& 3 0  yields 0
			&(1 6 3) yields 1
			&(1 6 0) yields 0

		| logical or : if at least one of the operands is non-zero (true), then 1, else zero (false)

			| 8 0 yields 1
			| 0 0 yields 0
			| 4 5 yields 1
			|(0 5 0) yields 1
			|(0 0 0) yields 0

		x logical exclusive or : only true if exactly one of the operands is zero

			x 7 0 yields 1
			x 0 0 yields 0
			x 7 7 yields 0
			x(0 0 0) yields 0
			x(0 0 5) yields 1
			x(0 5 5) yields 0
			x(5 5 5) yields 0

	Flow

		; two statement combinator

			Yields the value of the second statement.
			This operator is useful to supply a series of statements to operators that expect only one executable statement,
			like the ? or W(hile) operator.

			;4 30 yields 30
			;$2 10 v2 yields 10
			;;$0 4+:0 5 51 return 51 after having affected variable number 0

		? "If a, then b, else c"

			Yields operand 2 if operand 1 is not zero, else operand 3.

			?4 1 2 yields 1
			$50 0 ?v50 1 2 yields 2

		W While

			While operand 1 is non-zero, the statement in operand 2 is executed.
			If more than one statement is needed in operand 2,
			use the ; combinator operator.
			The W operator returns the value of its last executed statement.

			$0 10$1 0Wv0;+:1v0:-0 1v0
				yields the summation of 10 (10 + 9 + ... + 1)

			For readability, this can also be written as

			$0 10
			$1 0
			W
				v0
				;
					+:1 v0
					-:0 1
			v0

			Note: without the combinator operator (;),
			variable 0 wouldn't be decreased in every iteration,
			and a never-ending loop would crash the Laconic interpreter on a numeric overflow:

			$0 10
			$1 0
			W
				v0
				+:1 v0
			-:0 1
			v0

		F For-loop

			F startValue endValue increment counterVariable statement

			The F operator takes 5 arguments :
			- the starting value of the loop counter
			- the end value of the loop counter
			- the number the loop counter is incremented with after every iteration
			- the variable number that will hold the current loop counter
			- an operator executed in each iteration.

			The F operator
			1. starts by initializing its loop counter with its 1st argument,
			2. executes its 5th and subsequent arguments
			3. increases or decreases its loop counter with its 3rd argument and stores it in the variable indicated in the 4th argument
			4. checks if the loop counter is still in the range between its 1st and 2nd argument, inclusive,
			5. if so, repeats from step 2.

			If you want to execute more than one operator, either
			- use the ; operator
			- or use the ( ) operators.

			$0 1 F3 11 2 1 *:0 v1 v0 yields the product of all odd numbers from 3 up to 11

			More readably :
			$
				0
				1
			F
				3
				11
				2
				1
				*:
					0
					v1
			v0

			(The same can be calculated using the 'W' loop operator :)
			$0 3 $1 1 W!>v0 11 ;*:1 v0 +:0 2 v1

			If the start value > end value, the increment number is subtracted from the counter
			- there's no need to give a negative increment number.

			E.g.: the calculation of a factorial:

				w[sEnter a number to get the factorial of:]
				$0r
				$1 1
				F
					v0    [c start value]
					1     [c end value]
					1     [c Positive increment; will be subtracted if variable 0 > 1]
					2	    [c counter variable]
					*:1v2 [c loop execution body]
				v1


	Input & Output

		w	write the value of an expression to standard output and returns that value.

					Note that no newline or CR characters are inserted automatically.

					$0 7 wv7

			If more than one argument is given, they are all written to standard output.

		r read a line from standard input.

			This command reads a line of text from standard input and returns the result:

			If the line of text is a valid representation of a number in the current input base, it's returned as a number value;
			otherwise, as a string value.

			Any operands are ignored.

			E.g.:
				$23r
					stores the input read from standard input in variable 23.

	Other

		( Operand number override

			Overrides the number of operands for the preceding operator.
			Instead of taking its default number of operands (e.g., 2 for addition),
			the operator will take all juxtaposed operands after it until the ')' operator is found.

			E.g.:

				* + 2 3 4	yields 20.
				*(+ 2 3 4) yields 9 (as the * operator didn't find a second operand, that defaults to 1).

			Note that this override operator only affects the single operator preceding immediately (bar whitespace or comments).
			If the atom before the '(' operator is a number, string or comment, the '(' operator won't have any effect.

		) End of operand number override - see '('. 

		` (Backtick) : modifies operation of previous operator:

					° 1 yields the value of 1 radian in degrees.
					°`1 yields the value of 1 degree in radians.

					S 1 yields sine of 1 radian
					S`1 yields arcsine of 1 in radians

					The same goes for the C(osine) and T(angent) operators.

					i 1.5 yields 1 (truncate to same or smalller integer, towards zero)
					i`1.5 yields 2 (fill to same or greater integer, away from zero)

					b 2 sets base of subsequent input numbers
					b`2 sets base of subsequent output numbers

					The ` operator only takes one operand, and this number can't be overridden.

					However, if the number of operands of the modified operator is overridden,
					one is free to put the ` operator inside or before the (operands) group :

					°`1
					°(`1)
					°`(1)

						all yield the same result.

		b n : Base of subsequent input numbers (numbers in the script).
					(to be implemented)

					Bases from 2 up to any large number are supported.
					If any other base is requested (base < 2), base 10 is assumed.

					Note:
						Base 1 is useless, as no number greater than 0 can be expressed.

					Non-integer base numbers are truncated to an integer base.

					Caution : when this command is repeated after a first b n command,
					the value of the second parameter might be different than what you expect.

					E.g.:
					b8 [c Octal numbers used] b10 [c Octal 10 = 8 in base10 ! => still octal numbers used].

					In order to switch to decimal numbers after octal ones, one would need to specify :

					b8 [c Octal numbers used] b12 [c Base 10 used again]

					The b operator returns the value of its base.

		b`n : Base of subsequent output numbers (displayed as final output and by the w(rite) operator).
					(to be implemented)

					The b` operator returns the value of its base.

		o Operator designated by number, 2 operands

			(lower case o)

			The number of characters to represent operators is limited.
			Moreover, for most people, the beautiful 汉Han 字Zi are difficult to enter using a keyboard. 
			That's why there are also operators that are designated by a number; these are called "enumerated operators".
			The o and O operators take that number as their first operand in order to perform the operation of an enumerated operator.

			The difference between both operators is that
			- the lower case o operator takes 2 operands : the enumerated operator number and one operation operand;
			- the upper case O operator takes 3 operands : the enumerated operator number and two operation operands.

			Both operators, however, can have their number of operands overridden by the ( and ) operators,
			in which case they can be used interchangeably.

			The enumerated operators are :

			o  0  opd
							Sign
								if a > 0, yields 1
								if a = 0, yields 0
								if a < 0, yields -1

								If there are more than 2 operands :
									if operands 2 until last > 0, yields 1
									if operands 2 until last < 0, yields -1
									else, yields 0.

								e.g.
									o0 ~14 yields -1.
									O(0 300) yields 1.
									O0 ~3 5 yields 0.

			o(2 dividend divisor remainder_var)

							Integer division and remainder
								(to be implemented)

								Returns the integer quotient of dividend/divisor
								and stores the remainder in the variable designated by remainder_var.
								This allows both the quotient and the remainder to be known using one division.

								e.g
									o(2 17 3 100)	yields 5 and stores 2 in variable 100.

			o 3 num
							A string having one character having Unicode point <num>.

							If more operands are provided, a string having characters from the given unicode points is returned.

							e.g.
								03 10	yields the newline character.
								o(3 1057 1086 1102 1079) yields "Союз".

			o 4 exp
							Returns type of expression

								o4 39        yields 1 : numeric
								o4 [sWhat?]  yields 2 : string
								An empty expression will yield 0.

			o  6  seq

							Fibonacci number
								(to be implemented)

								(F is the 6th letter.)
								The seq(uence number) operand is truncated to an integer and converted to its
								absolute value before being used to get a Fibonacci number.
								
								e.g.
									o6 0 yields 0
									o6 1 yields 1
									o6 2 yields 1
									o6 3 yields 2
									o6 4 yields 3
									o6 5 yields 5
									o6 6 yields 8
									o6 6.1 yields 8
									o6 ~6.1 yields 8

			o(7 year month day)

							Day of week
								(to be implemented)

								Returns a number from 0 to 6, where 0 is Saturday and 6 is Friday.

								If the day operator is ommitted, day "0" is presumed - i.e., the last day of the previous month.
								
								e.g.
									o(7 2024 5 27)	yields 3: monday.
									O 7 2024 5			yields 3: tuesday.

			o(8 year month day)
							(to be implemented)

							Sequence number of a day, assuming

								- January 1, year 0001 AD was day 1;
								- December 31, year 0001 BC was day -1.

								(Laconic's calendar operators calculate within the fiction
								of the Gregorian calendar having been used since Roman imperial era.)
		
		O Operator designated by number, 3 operands
		
			(upper case O)
			
			See the explanations for the lower case o operator.

	Z Set options

		Z optionNr value

		(Normally, these options precede all other statements.)
		If the first operand refers to an unknown option,
		the operator and its operands are ignored.

		Z 0 n : Precision "orb" for =-operator.
					 Default : 0; if n is negative, this default is restored.

		Z 1 n : maximum number of loops executed by F- or W-operator.
					 If 0, no maximum is imposed, which removes the protection against infinite loops.
					 Default : 10,000.

		Z 2 n : number of digits before fractal dot in output
					(to be implemented)

					If n=0, only the numbers needed will be output.

		Z 3 n : number of digits after fractal dot in output
					(to be implemented)

					If n=0, only the numbers needed will be output.
