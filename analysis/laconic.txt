LACONIC

		// TODO: explain standard number of operands and how to deviate from it.
		// TODO: indicate the standard number of operands for every operator.

	General syntax

		The laconic language is Polish expression interpreter :

			*+4 2 3

		evaluates to 18.

		A laconic expression consist of atoms that can either be
		- operators
		- numbers
		- string bracket contents
		- comment bracket contents
		- number bracket contents

		All atoms are case-sensitive.

		If there are more atoms than expected by the preceding operators,
		the preceding results are discarded and the value of the remaining expression is returned.

		E.g.:

			*+4 2 3 25

		will return 25, just like

			*+4 2 3 + 19 6

	Operators

		All operators consist of a single character that precedes its operands.

		See below for a detail explanation of each operator.

		There's never a need to separate an operator from preceding or following atoms using a whitespace,
		but it's permitted for readability.

		Note: the characters " and ' are nowhere used in Laconic, as they interfere with Linux command line syntax.

	Numbers

		Numbers consist of characters 0 up to 9, and may contain exactly one period as fractal separator. (Unary minus, ~, is an operator.)
		If the number is between 1 and -1 exclusive, the period may be the first character of the number.
		For readability, underscores _ may be inserted anywhere in a number :
		(In fact, prior to the interpretion of a formula, all underscores are discarded from it.)

		Eg.:
			.000_001 = 0.000001
			1_000_000 = 1000000

		A number is allowed to end with a period :

			40. = 40

		And a sole period is interpreted as zero :

			. = 0

		Note that a second period in a number is considered to be the start of the repeating part of a number:

			12.3.8 is interpreted as 12.3888...

			so

			12.3.9 yields 12.4

			(See 
				Su, Francis E., et al. “Why Does 0.999… = 1?.” Math Fun Facts
				https://math.hmc.edu/funfacts/why-does-0-999-1/
			)

		A third period in a number is interpreted as the start of a new number between 1 and ~1 exclusively:

			+1.0.0.2

			is interpreted as

			+1 .2
			
			and yields

			1.2

			Using the Z 4 n command one can use other bases than 10 for the script's numbers.

			However, as non-decimal-digit characters are interpreted as commands,
			numbers using a base larger than 10 and having digits above 9
			should be enclosed in a [n...] clause. E.g.:

			Z4 16 [n1F] yields 31(base10)

			but

			Z4 16 10 yields 16(base10)

		Number bases

			The default number base is base10.

			Digits for bases greater than 10 consist of 0 to 9 and the appropriate number of upper case letters needed:

			base  2 :  0-1
			base  3 :  0-2
			base  8 :  0-7
			base 10 :  0-9
			base 11 :  0-9 and A
			base 12 :  0-9 and A-B
			base 16 :  0-9 and A-F
			base 17 :  0-9 and A-G
			base 36 :  0-9 and A-Z

			If a number expressed in a base higher than 36 has digits greater than 9,
			it has to be expressed as number bracket contents: [n...] clauses as series of base10 numbers separated by spaces:

			Z4 50 +[n1 20] 3 yields 73(base10)

			This reduces calculating with hours, minutes and seconds to calculating seconds in base 60:

			Z5 60 Z4 60 /[n5 20 8] 4 yields 80(base10) : a fourth of 5 hours, 20 minutes and 8 seconds is 4802 seconds or 1 hour, 20 minutes and 2 seconds.
			
			Combinations of Z 5 n and Z 4 n commands allow conversion of numbers between bases.
			In order to avoid mistakes in the specification of the output base,
			it's best to issue the Z 5 n expression before the Z 4 n expression.

			It's even possible to process numbers of different bases together:

			*17 ;Z4 16 21 yields 561(base10).

	String brackets content

		Strings are enclosed between [s and ]

		Eg.:

			[sKunji Namparshespa] yields the string "Kunji Namparshespa".

		For numerical operations, the Laconic interpreter obtains the numeric value of a string
		by simply treating it as a Laconic expression itself.
		Thereby, characters that are no operators are ignored and treated as separators.

	Comment brackets content

		Comments are enclosed between [c and ]

		Eg.:

			$20 100[c Let's populate variable 20 with 100.]v20[c This entire expression should yield 100.]


	Whitespace

		Whitespace (any number of blanks, tabs, CR, LF) is treated as atom separator.

		As operators consist of only one character, they don't need to be separated by whitespace from anything else; two consecutive numbers, however, do.

Operators

	Basic arithmetic

		~ Unary minus

			+1~4 yields ~3
			-1~4 yields 5

		+ Addition of next two operands

			+5 6 yields 11

		- Subtraction

			-6 5 yields 1

		* Multiplication

			* 38 ~5 yields ~190

		^ Power (exponent)

			^ 2 .5 yields 1.4142...

		% Modulo (Remainder)

			%7 3 yields 1
			%7.1 3.1 yields .9

	Variables

		$ Variable assignment

			Variables are designated by any number, including negative and non-integer ones.
			However, this assignment operator truncates the fractal part of non integer numbers:

			$4.2 10 assigns 10 to variable number 4.
			$4.9 10 assigns 10 to variable number 4 also.
			$~4.9 10 assigns 10 to variable number -4.

			$0+2 8 assigns 10 to variable number 0.

			$+3 1+2 8 assigns 10 to variable number (3 + 1), so variable number 4.

		v variable value

			$2 30 +v2 4 yields 34

		: change previous operator to an assignment operator

			changes the operation of the previous operator into an assignment operation that
			- uses the first operand as a variable number,
			- uses this variable's value as the first operand,
			- computes the value resulting from processing its operands,
			- assigns the resulting value to the same variable
			- and returns the assigned value :

			+:0 5 means $0 +v0 5 (Assign to variable(0) the value of variable(0) plus 5)
			~:2   means $2 ~v2   (Convert the value of variable 2 to its opposite)

			Note: the ':' operator affects the first preceding operator, if any.
			The ':' operator has to be put immediately after the operator it is meant to affect,
			otherwise the results are unpredictable.

		u use variables array having given number

			Variables are stored in one of several arrays.
			Each array has a number.
			Using the 'u' command, you can change the array of variables to be used
			for all subsequent variable-related operations.

			Default is array 0.

			$5 20 v5 yields 20, because the current variables array hasn't been changed.
			$5 20 u1 v5 yields 0, because that's the default value for an unknown variable in an array.

	Comparison

		= equality

			Yields 1 if both operands are equal, else 0.

			$0 5 =v0 5 yields 1

			Using the ( and ) operators and more operands,
			one can test if a series of expressions is equal:

			$1 -15 3 =(12 +7 5 *3 4 /36 3 v1) yields 1

			The equality operator takes the precision orb into account.

				(The orb can be set using expression Z 0 n)

			Z0 .1 =21.3 21.35 yields 1

		< less than:

			< 5 20 yields 1

			!< 5 5 yields 1 (greater or equal)
			!< 6 5 yields 1

			Using the ( and ) operators and more operands,
			one can test if a series of numbes is ascending:

			<(2 8 50 401 800) yields 1

		> 

			> 50 20 yields 1

			!> 5 5 yields 1 (less or equal)
			!> 6 50 yields 1

			Using the ( and ) operators and more operands,
			one can test if a series of numbes is descending:

			>(701 90 87 4) yields 1

	Logic

		Note:

			0 = false, everything else = true.

		! not

			Converts 0 to 1, and everything else to 0.

			!4 yields 0
			!1 yields 0
			!0 yields 1

			Used with more than the standard one operand,
			! can be used to test if a series of expressions are all 0.

			!(0 -4 4 * 25 0) yields 1
			!(0 0 9) yields 0

		& logical and : if all operands are non-zero (true), then 1, else zero (false)

			& 7 -5 yields 1
			& 3 0  yields 0
			&(1 6 3) yields 1
			&(1 6 0) yields 0

		| logical or : if at least one of the operands is non-zero (true), then 1, else zero (false)

			| 8 0 yields 1
			| 0 0 yields 0
			| 4 5 yields 1
			|(0 5 0) yields 1
			|(0 0 0) yields 0

		x logical exclusive or : only true if exactly one of the operands is zero

			x 7 0 yields 1
			x 0 0 yields 0
			x 7 7 yields 0
			x(0 0 0) yields 0
			x(0 0 5) yields 1
			x(0 5 5) yields 0
			x(5 5 5) yields 0

	Flow

		; two statement combinator

			Yields the value of the second statement.
			This operator is useful to supply a series of statements to operators that expect only one executable statement,
			like the ? or W(hile) operator.

			;4 30 yields 30
			;$2 10 v2 yields 10
			;;$0 4:+0 5 51 return 51 after having affected variable number 0

		? "If a, then b, else c"

			Yields operand 2 if operand 1 is not zero, else operand 3.

			?4 1 2 yields 1
			$50 0 ?v50 1 2 yields 2

		W While

			While operand 1 is non-zero, the statement in operand 2 is executed.
			If more than one statement is needed in operand 2,
			use the ; combinator operator.
			The W operator returns the value of its last executed statement.

			$0 10$1 0Wv0;:+1v0:-0 1v0
				yields the summation of 10 (10 + 9 + ... + 1)

			For readability, this can also be written as

			$0 10
			$1 0
			W
				v0
				;
					:+1 v0
					:-0 1
			v0

			Note: without the combinator operator (;),
			variable 0 wouldn't be decreased in every iteration,
			and a never-ending loop would crash the Laconic interpreter on a numeric overflow:

			$0 10
			$1 0
			W
				v0
				:+1 v0
			:-0 1
			v0

	Other

		( Operand number override

			Overrides the number of operands for the preceding operator.
			Instead of taking its default number of operands (e.g., 2 for addition),
			the operator will take all juxtaposed operands after it until the ')' operator is found.

			E.g.:

				* + 2 3 4	yields 20.
				*(+ 2 3 4) yields 9 (as the * operator didn't find a second operand, that defaults to 1).

			Note that this override operator only affects the single operator preceding immediately (bar whitespace or comments).
			If the atom before the '(' operator is a number, string or comment, the '(' operator won't have any effect.

		) End of operand number override - see '('. 

	Z Set options

		Z optionNr value

		(Normally, these options precede all other statements.)
		If the first operand refers to an unknown option,
		the operator and its operands are ignored.

		Z 0 n : Precision "orb" for =-operator.
					 Default : 0; if n is negative, this default is restored.

		Z 1 n : maximum number of loops executed by F- or W-operator.
					 Default : no maximum; if n is negative, this default is restored.
					 If this maximum is violated by the formula, Eval throws an error.
					 (implemented)

		Z 2 n : number of digits before fractal dot in output

					If n=0, only the numbers needed will be output.

		Z 3 n : number of digits after fractal dot in output

					If n=0, only the numbers needed will be output.

		Z 4 n : Base of input number (numbers in the script).

					Bases from 2 up to any large number are supported.
					If any other base is requested, base 10 is assumed.

					Caution : when this command is repeated after a first Z 4 n command,
					the value of the second parameter might be different of what you expect.

					E.g.:
					Z4 8 [c Octal numbers used] Z4 10 [c Octal 10 = 8 in base10 ! => still octal numbers used].

					In order to switch to decimal numbers after octal ones, one would need to specify :

					Z4 8 [c Octal numbers used] Z4 12 [c Base 10 used again]

					When using binary numbers, even the first operand has to be expressed differently:

					Z4 2 [c Binary numbers used] Z100 1010 [c Base 10 used again]

		Z 5 n : Base of output number (displayed as output).

