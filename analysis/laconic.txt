LACONIC

		// TODO: add a -o parameter to the executable that gives an overview
		//				of all operators grouped by functionality (arithmetic, flow, settings, etc.)
		// TODO: add a -h parameter to the executable that gives comprehensive info
		//				about a specific operator (given in next parameter).

		Ideas for later versions:
			- use giantity or a third-party big number entity from crates.io; provide the choice between f64 or these as a Z§... choice.
			- Z,§settignName would give the value of a setting.
			- provide operators or constants for conversion between imperial and continental
				quantities for size, volume, speed, temperature, weight e.a.
			- provide calculations with complex numbers.
			- embed data about the first n prime numbers; make Laconic prime-savvy by providing an operator that returns the nth prime.
			- provide manipulation of bytes, so even non-text files can be read and written.
				This would require a new ValueType: ValueType::ByteArray.
			- provide bitwise operators on byte arrays.
			- A second period in a number can be considered to be the start of the repeating part of a number:
				12.3.8 would interpreted as 12.3888...
				so
				12.3.9 yields 12.4
				(See 
					Su, Francis E., et al. “Why Does 0.999… = 1?.” Math Fun Facts
					https://math.hmc.edu/funfacts/why-does-0-999-1/
				)
				(This may not be feasable using f64.)
			- provide RegEx functionality in finding and replacing substrings.
			- provide an operator
					w,, filepath expression

						Writes the outcome of the expression to a file, appending to it
						(instead of overwriting it).
			- Provide an array (matrix?) value type having arbitrary dimensions, and support all meaningful operators on it.
			- Provide an operator that writes an SVG file containing a graph
				based on arrays of variables.
			- Provide an operator that outputs if there is precision loss
				after a floating-point operation, and how much.
			- Provide a second way of adding more operands than expected to an operator,
				by preceding the supernumerous operands with '#'.
				(The existing way is using parentheses.)
			- Provide a summation operator.
			- Provide a factorial operator.
			- Provide an operator that returns the current data as a Gregorian sequential number.
			- Provide an operator that returns the current time as milliseconds/ticks since ... ?
			- Provide a variant E, of the E operator that converts standard infix notation to Polish notation before evaluating the string.

		* Characters assigned (or to be assigned) to operators:
			~+-*/%^$():,;=<>!&|?°€¶AaBbCcEeFiKklMmNnOopqRrSsTtUVvWwXxZ

		*	Implemented operators:
			~+-*/%^$():,;=<>!&|?°€¶AaBbCcEeFiKklMmNnOoqpRrSsTtUVvWwXxZ

		* Characters not to be used as operator:
			' " \   	Interfere with command line syntax or string literals
								in Rust code or calling modules.
			. [ ] § _ Have other meanings in Laconic.
			{ }				Can be used to delimit Laconic expressions in other contexts.
			Ø					Capital O with stroke; looks too much like zero in most fonts.
			whitespace

		* Common characters not used yet:
			`´#@£µ²³DdfGgHhIJjLPQuz
			
		Note the Unicode code point of some characters not on all keyboards:
			^ 005E Circumflex accent
			` 0060 Backtick or Grave Accent
			~	007E Tilde
			£ 00A3 Pound
			§ 00A7 Section (paragraph) sign (Alt-Shift-S)
			° 00B0 Degrees sign (Alt-Shift-:)
			² 00B2 Squared
			³ 00B3 Cubic
			´ 00B4 Acute accent
			µ 00B5 Mu
			¶ 00B6 Pilcrow (AltGr-r)
			Ø 00D8 Uppercase stroked O
			ø 00F8 Lowercase stroked o
			€ 20AC Euro

	General syntax

		The Laconic language is a Polish expression interpreter :

			*+4 2 3

		evaluates to 18.

		A Laconic expression consists of atoms that can either be
		- operators
		- numbers
		- simple strings
		- string bracket contents
		- comment bracket contents
		- number bracket contents

		All atoms are case-sensitive.

		If there are more atoms than expected by the preceding operators,
		the preceding results are discarded and the value of the remaining expression is returned.

		E.g.:

			*+4 2 3 25

		will return 25, just like

			*+4 2 3 + 19 6

	Operators

		All operators consist of a single character that precedes its operands.

		See below for a detail explanation of each operator.

		There's never a need to separate an operator from preceding or following atoms using a whitespace,
		but it's permitted for readability.

		Note: the characters " and ' are nowhere used in Laconic, as they interfere with command line syntax.

		Note: there are also named operators - see the O and o operators.

		Every operator has a default number of operands it expects. E.g., the + operator expects two operands :
		+ 1 2 yields 3.

		However, many operators can operate on less or more operands, too, but in order to deviate from the default number, the ( and ) operators have to be used:

		+(1 2 3) yields 6.
		+(27) yields 27.

	Numbers

		Numbers consist of characters 0 up to 9, and may contain exactly one period as fractal separator. (Unary minus, ~, is an operator.)
		If the number is between 1 and -1 exclusive, the period may be the first character of the number.
		For readability, underscores _ may be inserted anywhere in a number :
		(In fact, prior to the interpretion of a formula, all underscores are discarded from it.)

		Eg.:
			.000_001 = 0.000001
			1_000_000 = 1000000

		A number is allowed to end with a period :

			40. = 40

		And a sole period is interpreted as zero :

			. = 0


		Surplus periods in a number will be ignored:

			+1.0.0.2

			is interpreted as

			+1.002
			
			and yields

			1.002

		Using the b n command one can use other bases than 10 for the script's numbers.

			However, as non-decimal-digit characters are interpreted as commands,
			numbers using a base larger than 10 and having digits above 9
			should be enclosed in a [n...] clause. E.g.:

			b 16 [n1F] yields 31(base10)

			but

			b 16 10 yields 16(base10)

		Number bases

			The default number base is 10.

			However, using the b and b, operators, one can switch to other bases for input and output.

			Digits for bases greater than 10 consist of 0 to 9 and the appropriate number of upper case letters needed:

			base  2 :  0-1
			base  3 :  0-2
			base  8 :  0-7
			base 10 :  0-9
			base 11 :  0-9 and A
			base 12 :  0-9 and A-B
			base 16 :  0-9 and A-F
			base 17 :  0-9 and A-G
			base 36 :  0-9 and A-Z
			base 37 :  0 - 9 and 10 - 36
			base 200 : 0 - 9 and 10 - 199

			Numbers in bases higher than 10 having digits above 9 should be enclosed in number bracket contents : [n...].

			e.g.:
				b16 [n1A] yields 26.
				b16 1A		will consider the A character to be an operator.
				b16 11    yields 17.

			If a number expressed in a base higher than 36 has digits greater than 35,
			it has to be expressed as number bracket contents: [n...] clauses as series of base10 numbers separated by spaces:

			b50 +[n1 20] 3 yields 73(base10)

			This reduces calculating with hours, minutes and seconds to calculating seconds in base 60:

			b,60 b60 /[n5 20 8] 4 yields 80(base10) : a fourth of 5 hours, 20 minutes and 8 seconds is 4802 seconds or 1 hour, 20 minutes and 2 seconds.
			
			Combinations of b,n and bn commands allow conversion of numbers between bases.
			In order to avoid mistakes in the specification of the output base,
			it's best to issue the b,n expression before the bn expression.

			It's even possible to process numbers of different bases together:

			*17 ;b16 21 yields 561(base10).

			If a number has a digit which is too high for its base, that digit is reduced to the highest one:

				e.g.:
					b 2 104
						yields the same as
					b 2 101
						to wit 5(base10).

	Strings

		Strings are either
			- enclosed between [s and ] : string bracket contents

			- simple strings: enclosed between any of
				§ and whitespace
				§ and [
				§ and (
				§ and )
	
				Note that the § character doesn't terminate a simple string, so it can be part of one.

		Eg.:

			[sKunji Namparshespa] yields the string "Kunji Namparshespa".
			§Petrov yields the string "Petrov".

		If any of their operands is a string, some numerical operators will perform string-related operations :

			+	Concatenation, converting any numeric operand to a string;

				Thus
					$20 353 + [sTotal: ] v20
				yields
					"Total: 353"

			+§ number
				is a way of converting a number to a string in a format dictated by the latest
				o§fmt
				statement.

		Other numerical operators, or other combinations of number and string operands,
		will throw errors.

	Comment brackets content

		Comments are enclosed between [c and ].

		They are completely ignored by Laconic.

		Eg.:

			$20 100[c Let's populate variable 20 with 100.]v20[c This entire expression should yield 100.]

	Whitespace

		Whitespace (any number of blanks, tabs, CR, LF) is treated as atom separator.

		As operators consist of only one character, they don't need to be separated by whitespace from anything else; two consecutive numbers, however, do.

Operators

	Basic arithmetic

		~ Unary minus

			+1~4 yields ~3
			-1~4 yields 5

		+ Addition of next two operands

			+5 6 yields 11

		- Subtraction

			-6 5 yields 1

		* Multiplication

			* 38 ~5 yields ~190

		/ Division

			/ 504 7 yields 72

		/, Integer division and remainder
			/, dividend divisor

			Returns the quotient of the integer division, and pushes the remainder on the stack.

			E.g.:
				/, 20 7
				Returns 2 after having pushed 6 on the stack, so
				/, 20 7 k
				would return 6.

		% Modulo (Remainder)

			%7 3 yields 1
			%7.1 3.1 yields .9

		^ Power (exponent)

			^ 2 .5 yields 1.4142...

		l logarithm

				l base num

					l10 1000 yields 3 (actually, it yields 2.999....)
					le  num	 yields the natural logarithm of numbers.

		i Integer

			Truncates the fractal part of a number towards zero:

			i4.7 yields 4
			i~3.8 yields ~3
			i15 yields 15
			i~27 yields ~27

		i, ceiling: fills the number towards the next integer value away from zero,
					except if the number is already integer.

			i,.5 yields 1
			i,~.5 yields -1
			i,3 yields 3

		o§r num
			round

			Rounds num to the nearest integer.
			If a number is halfway two integers, rounds away from 0.

		a Absolute value

			a8 yields 8
			a~3 yields 3

		m Minimum

			m7 4.1 yields 4.1
			m~7 4.1 yields ~7
			m(4 2 1 19) yields 1

		M Maximum

			M7 4.1 yields 7
			M~7 4.1 yields 4.1
			M(4 2 1 19) yields 19

		s Sign

			if number > 0, yields 1
			if number = 0, yields 0
			if number < 0, yields -1

			If there are more than 1 operands :
				if operands 1 until last > 0, yields 1
				if operands 1 until last < 0, yields -1
				else, yields 0.

			e.g.
				s~14 yields -1.
				s300 yields 1.
				s(~3 5) yields 0.

	Trigonometric operators

		S sine of n radians
			
			S°,45 yields 0.7071...

		S, arcsine in radians

			°S,0.7071 yields 44.999 etc.

		C	cosine of n radians

			C°,45 yields 0.7071...

		C, arccosine in radians

			°C,0.7071 yields 44.999 etc.

		T	tangent of n radians

			T°,45 yields 1

		T, arctangent in radians

			°T,1 yields 44.999 etc.

		° degrees from radians

			°p yields 180

		°, radians from degrees

			°,180 yields 3.14159...

		A	y x

			four quadrant arctangent of y and x in radians
			(atan2)

		S,, hyperbolic sine (sinh)
		S,,, inverse hyperbolic sine (asinh)
		C,, hyperbolic cosine (cosinh)
		C,,, inverse hyperbolic cosine (acosinh)
		T,, hyperbolic tangent (tanh)
		T,,, inverse hyperbolic tangent (atanh)

	Strings

		q exp
				"Quote": converts an extression to a string.
				Numbers are converted according to the number formatting settings specified by
				o,§fmt ...

				This is shorter than +§ (expression), which would do the same

		q, exp
				"Quote": converts an extression to a string.
				Numbers are truncated towards zero and rendered without fractal digits.

				This is shorter than +,§ (expression), which would do the same

		+
			The plus operator will concatenate strings if any of its operands is a string.
			Concatenating with § or [s] (empty string) is a way of converting a number to a string.
			Mind that the current number format will be used.
			(This number format can be set using the o,§fmt command.)

			E.g.:
				+100 §€
					yields "100.000000€"
				o§fmt 0 +100 §€
					yields "100€"
				$0 79.2 +§ v0
					yields "79.200000"

		+,
			This variant of the plus command will also concatenate strings
			if any of its operands is a string,
			but any number operand will be truncated towards zero to an integer
			without any fractals or interpunction -
			only the minus sign will be perserve, if any.

			E.g.:
				+,100 §€
					yields "100€"
				+,~5.785 §$
					yields "-5$"

			This variant is useful for iterating through a series of prefixed variables, like the ones
			filled in by the o,§split operator.

		o,§sub string start_position number_of_characters
		o(§sub string start_position number_of_characters)

			Substring of string, taking number_of_characters characters from the start_position.
			Note that start_position is zero-based !

			Thus
				o,§sub [sLa Roche-en-Ardenne] 3 5
			yields
				"Roche"

			If number_of_characters is ommitted, the remaining characters until the end are extracted:
				O§sub [sLa Roche-en-Ardenne] 12
			yields
				"Ardenne"

			If the first argument is not a string, but a number, then that number is first converted to a string
			according to the o§fmt settings in effect.

		o§uni num
			A string having one character having Unicode point <num>.

			If more operands are provided, a string having characters 
			from the given unicode points is returned.

			e.g.
				o§uni 10	yields the newline character.
				b16 o(§uni [n421] [n43E] [n44E] [n437]) yields "Союз".

				Note: the ¶ operator and c§n constant operator also yield a newline character.

		O§ucv string position
			Returns the unicode point value of the character at [position] in [string].
			The position is zero-based!

			e.g.
				O§ucv §Союз 0
					yields 1057

			If the position operand is ommitted, the first character is used.

		o§len string
			Returns the length of the string.

			e.g.
				o§len §Theodorakis
					yields 11

				o§len §
				o§len [s]
					both yield 0

			If more than one operand is given, the total length of the string representations
			will be returned.

		o,§find string substring startpos

			Returns the start position of the first occurence
			of substring in string.

			If a fourth argument is present, it's used as the starting position for the search.
			The position returned, however, still counts from the start of the string.
			Otherwise, the search starting position is 0.

			The position returned is zero-based: the first character has position 0.

			If the substring is not found in string, this operator returns €:
			the empty value, so the way to test if the substring was found is to check
			on the type of the result:

			E.g.:
					$
						§pos
						O§find §Belgium §um
					?
						=1 tv§pos 
						w+, [sFound at position ] v§pos
						w[sNot found]

			Some more examples:
				O§find §Samovar §a
					yields 1
				o,§find §Samovar §a 3
					yields 5
				O§find [sNo hay remedio] §mejor
					yields €
				tO§find [sNo hay remedio] §mejor
					yields 0
				tO§find [sNo hay remedio] §hay
					yields 1
				O(§find §Samovar §a 3)
					yields 5

		O,,§repl string substring replacement varPos varSeq conditionRoutineName

			Replaces an occurrence of substring in string with replacement
			if the condition evaluates to a value that is not 0 (zero) or € (the Empty value).

			The condition has to be passed as the name of a routine
			defined previously using the R, operator -
			the variant that accesses the calling code's memory.

			The condition routine can make use of two variables, the names or number
			of which are passed in the varPos and varSeq operands.

			(The names varSeq and varPos are examples. You can choose any name or number.)

			If the condition routine hasn't been defined before,
			no replacement is performed.

			varPos :
			When the condition routine is called,
			varPos will hold the (zero-based) start of the occurrence
			of substring found in the original string.

			varSeq:
			When the condition routine is called,
			varSeq will hold the (zero-based) sequence number of the occurrence.

			If the varPos, varNum and condition operands are ommitted,
			all occurrences of substring will be replaced.

			The operator returns a string
			in which the requested replacements have been performed.

					e.g.
						$§replaced o,§repl §philadelphia §ph §f
							puts "filadelfia" in variable §replaced.

						R,§replCond =v§seq 0
						$§replaced O,,§repl §philadelphia §ph §f §pos §seq §replCond
							puts "filadelphia" in variable §replaced.

						R,§replCond >v§seq 0
						$§replaced O,,§repl §philadelphia §ph §f §pos §seq §replCond
							puts "philadelfia" in variable §replaced.

						R,§replCond >v§seq 5
						$§replaced O,,§repl §philadelphia §ph §f §pos §seq §replCond
							puts "philadelphia" in variable §replaced.

						R,§replCond =v§pos 0
						$§replaced O,,§repl §philadelphia §ph §f §pos §seq §replCond
							puts "filadelphia" in variable §replaced.

						R,§replCond >v§pos 4
						$§replaced O,,§repl §philadelphia §ph §f §pos §seq §replCond
							puts "philadelfia" in variable §replaced.

						R,§replCond 1
						$§replaced O,,§repl §philadelphia §ph §f §pos $seq §replCond
							puts "filadelfia" in variable §replaced.

						R,§replCond 0
						$§replaced O,,§repl §philadelphia §ph §f §pos §seq §replCond
							puts "philadelphia" in variable §replaced.

						R,§replCond =v§pos 0
						$§myCity §philadelphia
						O,,§repl :§myCity §p §P §pos §seq §replCond
							puts "Philadelphia" in variable §myCity.

				(Note that all string operations are case-sensitive.)

				Note: as the R, operator returns the name of the routine itself,
				it can be used as the routine-name operand:

						$
							§replaced
							O,,
								§repl
								§philadelphia
								§ph
								§f
								§pos
								§seq
								R,
									§replCond
									=v§pos 0

		o§lower string

			Returns the all lower-case form of a string.

				e.g.
					o§lower §McIntosh
						yields "mcintosh"

		o§upper string

			Returns the all upper-case form of a string.

				e.g.
					o§upper §McIntosh
						yields "MCINTOSH"

		o§proper string

			Returns the all proper-case form of a string:
			the first character in upper case, the rest in lower case.

				e.g.
					o§proper [sADDIS ABEBA]
						yields "Addis Abeba"

		o,§split string separator varNamePrefix

			Split a string in its fragments separated by a separator string.
			The fragments will be stored in variables the names of which
			consist of the given varNamePrefix + 0, 1, 2, 3 etc.

			All arguments should be strings.
			
			The operator returns the number of the resulting fragments, which will always be greater than zero.

				E.g.:
					$
						§nrCities
						o,
							§split
							[sBrugge,Arlon,Liège]
							§,
							§city
					F
						0
						v
							§nrCities
						1
						§count
						w
							+
								v
									+,
										§city
										v§count
								¶

					will write the three city names in the original string on separate lines.

			If the separator is an empty string (§ or [s]), every character of the source string
			will be copied to a variable.

			Note that the numbers after the varNamePrefix will have no fractal part or interpunction.

			In combination with the r, operator, this allows for awk-like file processing as well as reading of CSV files.

	Constants (zero-operand operators)

		e Euler's number

		p Pi

		€	the Empty value.

			This is the same as c§empty.

		¶ newline character
			
			For keyboard input, try AltGr-r.
			(¶ is U+00B6.)

			This is the same as c§n

		c	name
			named constants

			c§empty
				The Empty value; the € character is not available on every keyboard.

			c§gold
				Golden Ratio (sectio aurea)
				Calculated as (1 + sqrt(5))/2

			c§cogold
				Conjugate of the Golden Ratio
				Calculated as (1 - sqrt(5))/2

			c§n
				newline character
				This is the same as ¶

			c§rtn
				the name of the executing routine.
				If called outside of a routine, returns "main".

			c§utc system time as universal time in seconds since 1970-01-01 00:00:00 UTC.
				(Seconds in Unix Epoch)

	Variables

		$ Variable assignment

			Variables are designated by any number, including negative and non-integer ones.
			Apart of that, any string may be used as variable designator, either in simple or bracket form.

			$4.2 10 assigns 10 to variable number 4.2
			$~4.9 10 assigns 10 to variable number -4.9

			$§startValue 10 assigns 10 to variable "startValue"
			$[sstart value] 10 assigns 10 to variable "start value"

			$0+2 8 assigns 10 to variable number 0.
			$+3 1+2 8 assigns 10 to variable number (3 + 1), so variable number 4.

			If the $ operator has more than two operands (used with parentheses),
			then operands 3 up to the last one are assigned to consecutive variables:

			$(10 20 4 5)
				assigns
					20 to variable 10,
					4  to variable 11 and
					5  to variable 12.

			If the $ operator has more than two operands and the first one has a string value,
			consecutive variables are assigned to also, to wit as follows:

			$(§reg 20 30 40 50)
				assigns
					20 to variable "reg0",
					30 to variable "reg1",
					40 to variable "reg2",
					50 to variable "reg3".

		v references a variable

			$2 30 +v2 4
				yields 34

			$§theNumber 11 +v§theNumber 9
				yields 20

		v, references a variable, or assigns and returns the second operand if that variable is empty

			$10 22 v,10 1 
				yields 22

			[c No initialization of var 10 done] v,10 1
				yields 1 

			[c No initialization of var 10 done] v,10 1 v10
				yields 1 

			$10 € v,10 1
				yields 1

		: references and assigns to a variable

			changes the operation of the parent operator into an assignment operation that
			- uses the value of the : operand as a variable number,
			- uses this variable's value as operand for the parent operator,
			- assigns the resulting value of the parent operator to the referenced variable
			- and returns the assigned value :

			+:0 5
				means $0 +v0 5 (Assign to variable(0) the value of variable(0) plus 5)

			+0 :5
				means $5 +0 v5 (Assign to variable(5) the value of 0 plus variable(5))

			~:2
				means $2 ~v2   (Convert the value of variable 2 to its opposite)

			*:§product 3
				means $§product *§product 3 (Assign to variable "product" its current value times 3)

			It is even possible to assign the value of the parent operator to two variables referenced as operands:

			$(1 10 20) +:1 :2 +v1 v2
				will yield 60, as the sum of 10 + 20 will be assigned to both variable 1 and 2.

			If using the () operators to override an operator's number of operands,
			and referencing the first operand using the : operator,
			one can choose to put this : operator before or after the ( operator:

			Both expressions do the same :
			+(:0 v1 v2)
			+:(0 v1 v2)

			The : operator takes always only one operand, and if followed by an () operand number overriding clause,  
			this clause is applied to the preceding operator,
			which may or may not be the parent operator.

			This might have surprising effects :

			$(1 10 20) +v2 :(1) v1

				will be interpreted as

			$(1 10 20) +v(2 :1) v1

				where the v operator will yield variable 2's value (20), but assigns it also to variable 1 !
				The + operator will then use v2 and v1 as its operands and yield 40.

		:, references and assigns to a variable, assigning as second default operand to the variable if empty.

			$§count €
			+:,§count 0 1
			v§count

				yields 1

	Stack

		K	expression(s)

			Puts the value of the expression on the stack.

			This operator can be used to pass data to routines.

		K, expression(s)

			Puts the value of the expression on the stack in reverse order.

			This makes it easier to push values on the stack in the order a routine wants to find them.

		k

			Gets the topmost element from the stack and removes it from the stack.

			This operator can be used by routines to read parameters.

		k,
			Stack depth: gets the number of items on the stack.

		K,,
			clears the stack.

	Comparison

		= equality

			Yields 1 if both operands are equal, else 0.

			$0 5 =v0 5 yields 1

			Using the ( and ) operators and more operands,
			one can test if a series of expressions is equal:

			$1 -15 3 =(12 +7 5 *3 4 /36 3 v1) yields 1

			The equality operator takes the precision orb into account.

				(The orb can be set using expression Z§prec n)

			Z§prec .1 =21.3 21.35 yields 1

		< less than:

			< 5 20 yields 1

			< §A §a yields 1
				Upper case characters are considered "smaller" than lower case ones,
				as they have a lower Unicode point.

			< 1_000_000 [sI am a string.] yields 1
				Numbers are considered smaller than strings.

			!< 5 5 yields 1 (greater or equal)
			!< 6 5 yields 1

			Using the ( and ) operators and more operands,
			one can test if a series of numbes is ascending:

			<(2 8 50 401 800) yields 1

			Note: uninitialized variables are considered "empty" and to be smaller than any other value,
			even smaller than negative infinity, which can be obtained by dividing a negative number by zero :

			< v§UnusedForNow /~1 0
				yields 1

		> 

			> 50 20 yields 1

			!> 5 5 yields 1 (less or equal)
			!> 6 50 yields 1

			Using the ( and ) operators and more operands,
			one can test if a series of numbes is descending:

			>(701 90 87 4) yields 1

			> §Brussels §Antwerp yields 1
			> §金 §gold yields 1 as Chinese characters have a higher Unicode point than Latin ones.
			> §1024 1024 yields 1, as the first operand is a string and the second a number.
			> 20 v§UnusedForNow yields 1, as an uninitialized variable is smaller than anything else.

	Logic

		Note: 0 = false, § (empty string) = false,
			[s] (empty string) = false,
			uninitialized variable (empty value) = false,
			c§empty = false,
			€ (the empty value) = false

			everything else = true.

		! not

			Converts false values to 1, and everything else to 0.

			!4 yields 0
			!1 yields 0
			!0 yields 1
			!v§NotUsedYet yields 1
			![s] yields 1
			!§ yields 1
			!!§ yields 0
			!§Hello yields 0
			![s Hello, Mylady] yields 0

			Used with more than the standard one operand,
			! can be used to test if a series of expressions are all 0.

			!(0 -4 4 * 25 0) yields 1
			!(0 0 9) yields 0
			!(§ § §Haha) yields 0

		& logical and : if all operands are non-zero (true), then 1, else zero (false)

			& 7 -5 yields 1
			& 3 0  yields 0
			&(1 6 3) yields 1
			&(1 6 0) yields 0

		| logical or : if at least one of the operands is non-zero (true), then 1, else zero (false)

			| 8 0 yields 1
			| 0 0 yields 0
			| 4 5 yields 1
			|(0 5 0) yields 1
			|(0 0 0) yields 0

		x logical exclusive or : only true if exactly one of the operands is zero

			x 7 0 yields 1
			x 0 0 yields 0
			x 7 7 yields 0
			x(0 0 0) yields 0
			x(0 0 5) yields 1
			x(0 5 5) yields 0
			x(5 5 5) yields 0

	Flow

		; two statement combinator

			Yields the value of the second statement.
			This operator is useful to supply a series of statements to operators that expect only one executable statement,
			like the ? or W(hile) operator.

			;4 30 yields 30
			;$2 10 v2 yields 10
			;;$0 4+:0 5 51 return 51 after having affected variable number 0

			Note:
				;(...) can combine more than two statements.

			The ; operator returns the value of the last statement or expression.

		? "If a, then b, else c"

			Yields operand 2 if operand 1 is not zero, else operand 3.

			?4 1 2 yields 1
			$50 0 ?v50 1 2 yields 2

		W While

			While operand 1 is non-zero, the statement in operand 2 is executed.
			If more than one statement is needed in operand 2,
			use the ; combinator operator.
			The W operator returns the value of its last executed statement.

			$0 10 $1 0 Wv0 ;+:1v0 -:0 1 v1
				yields the summation of 10 (10 + 9 + ... + 1)

			For readability, this can also be written as

			$0 10
			$1 0
			W
				v0
				;
					+:1 v0
					-:0 1
			v1

			Note: without the combinator operator (;),
			variable 0 wouldn't be decreased in every iteration,
			and a never-ending loop would crash the Laconic interpreter on a numeric overflow:

			$0 10
			$1 0
			W
				v0
				+:1 v0
			-:0 1
			v0

		F For-loop

			F startValue endValue increment counterVariable statement

			The F operator takes 5 arguments :
			- the starting value of the loop counter
			- the end value of the loop counter
			- the number the loop counter is incremented with after every iteration
			- the variable number that will hold the current loop counter
			- an operator executed in each iteration.

			The F operator
			1. starts by initializing its loop counter with its 1st argument,
			2. executes its 5th and subsequent arguments
			3. increases or decreases its loop counter with its 3rd argument and stores it in the variable indicated in the 4th argument
			4. checks if the loop counter is still in the range between its 1st and 2nd argument, inclusive,
			5. if so, repeats from step 2.

			If you want to execute more than one operator, either
			- use the ; operator
			- or use the ( ) operators.

			$0 1 F3 11 2 1 *:0 v1 v0 yields the product of all odd numbers from 3 up to 11

			More readably :
			$
				0
				1
			F
				3
				11
				2
				1
				*:
					0
					v1
			v0

			(The same can be calculated using the 'W' loop operator :)
			$0 3 $1 1 W!>v0 11 ;*:1 v0 +:0 2 v1

			If the start value > end value, the increment number is subtracted from the counter
			- there's no need to give a negative increment number.

			E.g.: the calculation of a factorial:

				w[sEnter a number to get the factorial of:]
				$0r
				$1 1
				F
					v0    [c start value]
					1     [c end value]
					1     [c Positive increment; will be subtracted if variable 0 > 1]
					2	    [c counter variable]
					*:1v2 [c loop execution body]
				v1

		B num

			Breaks the current F- or W-loop if num is 1, otherwise the enclosing F- or W-loop num levels above.

			If a 0 is passed, suppresses a previously set break target, if any.

		?, opr1 oprIfError optional:oprIfOk

			If operator opr1 is successful (no error),
			then its outcome is returned,
			else oprIfError's outcome.

			If a third operator oprIfOkis present,
			then that operator's outcome is returned if opr1 was successful.

			Both the operators oprIfOk and oprIfError can make use of a V operator,
			which will yield the result of the successful operation if called by oprIfOk,
			or the error value if called by oprIfError.

		V value of first operand of ?, operator.		

	Routines

		R defines a Routine which will have separate variables and can't use the variables of the calling code.

			E.g.:
				R§tau *2p
					defines a routine named "tau" that returns Tau, which is twice Pi.

			E.g.:
				R§tau *2p $§peripheryA *X§tau v§radA
					defines a routine and calls it.

			(These are just examples - it's more efficient to calculate Tau once and store it in a variable.)

			If a routine has to consist of more than one operator executed in series,
			these operators can
			- either be chained by ; (the combinator operator)
			- or else the R operator's operands can be enclosed in parentheses:

			E.g. both scripts to the same :
				R§revertStack ;;$(0kk) Kv0 Kv1
				R(§revertStack $(0kk) Kv0 Kv1)
			to wit, they define a routine that switches the order of the stack's top two items.

			As routines declared using the bare R operator (no ,) have a separate variables scope,
			any values stored in variables during these routines' operation are lost afterwards.
			If this is not desired, use the R, declaration operator.

			Parameter passing:

			As routines defined by the bare R operator (no ,) don't have access to the variables of the calling code,
			values have to be passed to it by putting items on the stack.
			Mind that the stack items are read in REVERSE ORDER : last-in, first-out.

			E.g.:
				[c This routine returns the average of the items on the stack.]
				R(
					§average
					$§count k,
					$§total 0
					W
						k,
						+:§total k
					/v§total v§count
				)

				[c Let us put some items on the stack and call the routine.]
				K(41 25 60 ~50 4)
				X§average
				[c This call should return 16.]

			Return value: the return value of the routine's last operator is returned.

			It is possible to call a previously declared routine from within another routine.

			(It is even possible to (re-)declare a routine within a routine. As the routines library is global during
			script execution, that second declared routine will be available after the first execution of the declaring routine.
			Anyway, that declared routine will be redeclared on every call of the declaring routine.
			This can be useful to have a different behaviour under the same routine name, depending on circumstances.)

		R, defines a Routine which will share the variables of the calling code.

			Behaves in the same way as the bare R operator, except that the routine
			will have access to the calling code's variables, so it can manipulate these.
			Values can be passed using both the stack or variables.

			E.g.:
				[c This routine swaps the value of two variables, the names of which are read from the stack.]
				R,(
					§swap
					$§swpVar1 k
					$§swpVar2 k
					Kvv§swpVar1
					$v§swpVar1 vv§swpVar2
					$v§swpVar2 k
				)

				[c Putting 4 in variable 0 and 8 in variable 1]
				$(0 4 8)

				[c Putting the names of both variables on the stack.]
				K(0 1)

				[c Calling the swap routine.]
				X§swap

				[c Checking the result.]
				w+[svar0: ] v0
				w+[svar1: ] v1

		X eXecutes a routine and returns the routine's return value.

			The first operand of the X operator should be a routine's name (or number).

			If any other operands follow, they are put on the stack before the routine is executed,
			so the routine can use these stack items as arguments.

			E.g.: both scripts do the same:
				X(§average 20 1 5 80)
				K(20 1 5 80) X§average

			If a non-declared routine is called, the Empty value is returned.

		X, eXecutes a routine and returns the routine's return value.

			The difference with the X operator is that the operands after the routine name are pushed in reverse order on the stack - see the K, operator.

	Input & Output

		w
			write the value of an expression to standard output and returns that value.

					E.g.:
						$0 7 wv0

					Note that no newline or CR characters are inserted automatically.
					You can, however, easily add a newline to any text using the + and ¶ operators: e.g.:

						w+¶[sCalculating ...]
						w+[sCalculating ...]¶
						w+(¶[sCalculating ...]¶)

			If more than one argument is given, they are all written to standard output.

		w, filepath expression

			Writes the outcome of the expression to a file, overwriting it.

		r read a line from standard input.

			This command reads a line of text from standard input and returns the result:

			If the line of text is a valid representation of a number in the current input base, it's returned as a number value;
			otherwise, as a flat, non-interpreted string value.

			Any operands are ignored.

			E.g.:
				$23r
					stores the input read from standard input in variable 23.

				Er

				reads a line from standard input and interpretes it as a Laconic expression or script.
				This script shares the same variables, stack e.a. as the calling script.
				(See the E operator for an example.)

		r, filepath

			reads a file and return its string content.
			The file should consist entirely of valid UTF-8 characters.
			If not, an error is thrown.

			E.g.:
				Er, filepath
					reads a script file and uses its contents as Laconic script code.
					(See the E operator.)

	Other

		( Operand number override

			Overrides the number of operands for the preceding operator.
			Instead of taking its default number of operands (e.g., 2 for addition),
			the operator will take all juxtaposed operands after it until the ')' operator is found.

			E.g.:

				* + 2 3 4	yields 20.
				*(+ 2 3 4) yields 9 (as the * operator didn't find a second operand, that defaults to 1).

			Note that this override operator only affects the single operator preceding immediately (bar whitespace or comments).
			If the atom before the '(' operator is a number, string or comment, the '(' operator won't have any effect.

		) End of operand number override - see '('. 

		, (comma) : variant operator: modifies operation of previous operator: E.g.:

					° 1 yields the value of 1 radian in degrees.
					°,1 yields the value of 1 degree in radians.

					S 1 yields sine of 1 radian
					S,1 yields arcsine of 1 in radians

					The same goes for the C(osine) and T(angent) operators.

					i 1.5 yields 1 (truncate to same or smalller integer, towards zero)
					i,1.5 yields 2 (fill to same or greater integer, away from zero)

					b 2 sets base of subsequent input numbers
					b,2 sets base of subsequent output numbers

					The , operator only takes one operand, and this number can't be overridden.

					However, if the number of operands of the modified operator is overridden,
					one is free to put the , operator inside or before the (operands) group :

					°,1
					°(,1)
					°,(1)

						all yield the same result.

					Some operators have more than one variant and take even more commas.

		N : number of operands of the preceding same-level operator.

				This allows for calculation of averages :

				/+(1 2 3 4 5) N
					yields 3.

				Note that the ( and ) operators are not considered by the N operator.

				If the preceding operator is the F or W operator, the number of iterations is returned.

				If there are no preceding operators, 0 is returned.

		b n : Base of subsequent input numbers (numbers in the script).

					Bases from 2 up to any large number are supported.
					If any other base is requested (base < 2), base 10 is assumed.

					Note:
						Base 1 is useless, as no number greater than 0 can be expressed.

					Non-integer base numbers are truncated to an integer base.

					Caution : when this command is repeated after a first b n command,
					the value of the second parameter might be different than what you expect.

					E.g.:
					b8 [c Octal numbers used] b10 [c Octal 10 = 8 in base10 ! => still octal numbers used].

					In order to switch to decimal numbers after octal ones, one would need to specify :

					b8 [c Octal numbers used] b12 [c Base 10 used again]

					The b operator returns the value of its base.

		b,n : Base of subsequent output numbers (displayed as final output and by the w(rite) operator).

					The b, operator returns the value of its base.

		t exp
				Returns type of expression

				t v§NotUsedYet     yields  0 : empty or uninitialized : an empty expression will yield 0.
				t 39               yields  1 : numeric
				t [sWhat?]         yields  2 : string
				Z§ign 1 t*(7)    yields 90: error (to wit, InsufficientOperands('*')).

		€
				Returns the Empty value.

		U string
				Returns a user-defined error, having the passed string as error message.

				Depending on the setting of Z§ign, this may or may not
				(0) stop script execution immediately (default behavior)
				(1) or simply pass an error value type to the higher-level operator.

		n exp
				Converts a string expression to a number.

				If the first operand is a string, the n operator converts it to a a number, if possible.
				If the first operand is empty, 0 will be returned.
				If the first operand is already a number, it will be returned as is.
				If the first operand is an error value, that error will be returned or thrown depending on Z§ign.

		o Operator designated by name, 2 operands

			(lower case o)

			The number of characters to represent operators is limited.
			Moreover, for most people, the beautiful 汉字 (Han zi) are difficult to enter using a keyboard. 
			That's why there are also operators that are designated by a name; these are called "named operators".
			The o and O operators take that name as their first operand in order to perform the operation of a named operator.

			The difference between both operators is that
			- the lower case o operator takes 2 operands : the named operator name and one operation operand;
			- the upper case O operator takes 3 operands : the named operator name and two operation operands.

			Furthermore, adding the comma operator to both the O and o operands increases their expected number of operands by (2 * number_of_commas), so

			- the o, operator takes 4 operands;
			- the O, operator takes 5 operands;
			- the o,, operator takes 6 operands;
			- the O,, operator takes 7 operands;
			etc.

			Both operators, however, can have their number of operands overridden by the ( and ) operators,
			in which case they can be used interchangeably and following commas don't affect the number of expected operands (they can still affect the behaviour, though).

			The operator's name, which is the first operand of the o and O operators, can either be a number or a string.
			For readability, however, strings are chosen for the implemented operators.

			In addition to the named operators handling strings, the below named operators have been implemented:

			o§version num
							Version of Laconic interpreter.

							The version information returned depends on the second operand:

							o§version 0 yields a string containing full version information, e.g.: "001.000.003"
							o§version 1 yields the major version as a string, e.g.: "1"
							o§version 2 yields the minor version as a string, e.g.: "0"
							o§version 3 yields the revision as a string, e.g.: "3"

			o(§fmt nr_of_fractal_digits fractal_separator thousands_separator)

							Set the output format for numbers when written using the w operator or output as string:

							nr_of_fractal_digits : the numbers displaying the fractal part of the number.
																If the number has more fractal digits, these will be rounded; otherwise,
																the number will be right-padded with zeroes.
																Default: 6

							fractal_separator : the character between the integer and fractal part of the number.
																Only the first character of whatever string is provided is used.
																Default : '.'

							thousands_separator : the character between groups of three digits.
																Only the first character of whatever string is provided is used.
																This won't be used for bases above 36.
																Default : empty string ([s])

							Note:
							- Laconic won't allow the fractal and thousands separator to be equal.
								A command to that effect will raise an error.
							- If you don't want a thousands separator, provide an empty string: [s] or §
							- This formatting is strictly for output.
								In Laconic script code and as input
								for the r(ead) operator, fractal separators should always be '.' dots and
								thousands separators, if any, '_' underscores.

							E.g.:
								o(§fmt 3 §, §.) 1200.25     returns 1.200,250 (European Continental style)
								o(§fmt 3 §, §) 1200.25      returns 1200,250
								o(§fmt 3 §, §) 1200.2526    returns 1200,253
								o(§fmt 6 §. §___) 1200.2526 returns 1_200.252_6

			o§fib index

							Fibonacci number from index.

								The index operand is truncated (not rounded) towards zero to an integer
								before being used as a Fibonacci index.
								
								e.g.
									o §fib 0 yields 0
									o §fib 1 yields 1
									o §fib 2 yields 1
									o §fib 3 yields 2
									o §fib 4 yields 3
									o §fib 5 yields 5
									o §fib 6 yields 8
									o §fib 6.1 yields 8
									o §fib 6.9 yields 8
									o §fib ~1 yields 1
									o §fib ~2 yields -1
									o §fib ~3 yields 2

								For positive indexes, the calculation is implemented as

									Fib(n) = for n > 0:  round((φⁿ - ψⁿ) / sqrt(5))

										where	φ = golden ratio: (1 + sqrt(5)) / 2
										and		ψ = conjugate of φ: (1 - sqrt(5) / 2

									(See https://en.wikipedia.org/wiki/Fibonacci_sequence#Relation_to_the_golden_ratio)

								For negative indexes, see

									https://en.wikipedia.org/wiki/Generalizations_of_Fibonacci_numbers

								(Generalized using F(n-2) = F(n) - F(n-1))

			o,§dow year month day

							Day of week

								Returns a number from 0 to 6, where 0 is Saturday and 6 is Friday.
								
								e.g.
									o,§dow 2024 5 27	yields 3: monday.

								If only one numeric argument is given, it's not understood as a year, but as the Gregorian day
								sequence number - see the o,§greg operator.

								e.g. o,§dow 2025 6 5	yields 5: thursday.

			o,§greg year month day

							Sequence number of a day in the Gregorian calendar, assuming

								- January 1, year 0001 AD was day 1;
								- December 31, year 0001 BC was day -1.

								(Laconic's calendar operators calculate within the fiction
								of the Gregorian calendar having been used since Roman imperial era.)

								No negative years are accepted.

			o§gregy sequence_number

							The year of the date the sequence number is associated with.
							Numbers smaller than 1 yield an error message.

			o§gregm sequence_number

							The month of the date the sequence number is associated with.
							Numbers smaller than 1 yield an error message.

			o§gregd sequence_number

							The day-in-month of the date the sequence number is associated with.
							Numbers smaller than 1 yield an error message.

			o§gregt sequence_number

							A YYYYMMDDWWW text representation of the date the sequence number is associated with.
							Numbers smaller than 1 yield an error message.
							(WWW = the weekday as an English abbreviation, from MON to SUN)

							E.g.:
								$§seq + o,§greg 2025 6 4 365 o§gregt v§seq
									yields
								"20260604WED"

							If a third string argument is given, this is used as a separator. E.g.:
								$§seq + o,§greg 2025 6 4 365 O§gregt v§seq §-
									yields
								"2026-06-04-WED"

							This separator can be any length; if a space is desired, pass it as [s ]:
								$§seq + o,§greg 2025 6 4 365 O§gregt v§seq [s ]
									yields
								"2026 06 04 WED"

			o§leap year

				Returns 1 if year is a leap year, else 0.

			O§gregn year month

				Days in month: returns the days in a given month in a given year.

			o§utcd number
			
				Converts a system time returned by c§time to a Gregorian day number as handled by o§gregt e.a.

			o§utch number

				Gets the hours since 00:00:00 UTC from a system time returned by c§time.

			o§utcm number

				Gets the minutes since last hour UTC from a system time returned by c§time.

			o§utcs number

				Gets the seconds as integer number since last minute UTC from a system time returned by c§time.

			o§utcf number

				Gets the fraction of the last second from a system time returned by c§time.

			o§utct number

				Converts a system time returned by c§time to an "HHMMSS UTC" string where SS are seconds
				formatted as dictated by the o,§fmt operator.

				If a third string argument is given, this is used as a separator. E.g.:
					o,§fmt 3 §, § O§utct 72074 §:
						yields
					"02:02:02,000:UTC"

				This separator can be any length; if a space is desired, pass it as [s ]:
					o§fmt 0 O§utct 72074 [s ]
						yields
					"02 02 02 UTC"

				Mind that the fractal part of the seconds is rounded, not truncated,
				to the number of fractal digits requested.

				E.g.:
					o,§fmt 2 §. § $§now + c§utc 7200 ++O§gregt o§utcd v§now §- §, O§utct v§now §:
						yields
					2025-08-16-SAT,23:29:41.08:UTC

		O Operator designated by name, 3 operands
		
			(upper case O)
			
			See the explanations for the lower case o operator.

		E eval: evaluates a string as a script and executes it.

			This script shares the variables, stack, e.a. from the calling command.

			In combination with the r operator, this allows input of Laconic script
			code during script execution:

			laconic 'w[sPlease enter a number: ] Kr w[sEnter an operation on that number (represented as k): ] Er'

			Furthermore, the E operator can also be used to import a library of laconic code: e.g.:

				given the file lib.lac having content

					R
						§Avg
						;;;
							$0 0
							$1 k,
							W
								k,
								+:0k
							/v0v1

				the command below can use the §Avg routine:

					laconic 'Er, §lib.lac K(8 6 4) X§Avg'

			Note: if you want a string to be evaluated by E to return a hard-coded string again, you've got to nest
			string markers: e.g.:

				E [s[s Hard coded string]]

			Otherwise, the hard-coded string will be interpreted as Laconic script code and executed, which will likely
			result in UnknownOperator errors.

	Z Set options

		Z optionNr value

		(Normally, these options precede all other statements.)
		If the first operand refers to an unknown option,
		the operator and its operands are ignored.

		Z§prec n : Precision "orb" for = operator.
					 Default : 0; if n is negative, this default is restored.

		Z§loops n : maximum number of loops executed by F- or W-operator.
					 If 0, no maximum is imposed, which removes the protection against infinite loops.
					 Default : 10,000.

		Z§quiet n : quiet execution

					If n = 0 (default), Laconic will output the value of its topmost operator after execution
					to standard output.
					Otherwise, nothing will be output.

					Output by the w operator is unaffected by this setting.

					Z§quiet 1
						does the same as the executable's -q parameter.

		Z§ign n : ignore errors

					If 0 (default), any error in any operation immediately stops execution
					of the entire script or expression.
					If not 0, the failing operator yields an Error(...) value, but execution continues.
					This way, loops with user input in every iteration can continue.

					Note: a script can test if a variable holds an Error value using the t operator.

					Z§ign 1
						does the same as the executable's -I parameter.
